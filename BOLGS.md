# Week 1: 7.3-7.9
My previous research explored the changes in Chinese strong ties culture in the context of the Internet and found that traditional strong ties were transformed into more multidimensional digital strong ties. In that week's research, I read a lot of literature, and in one of the studies, I pointed out that due to the emergence of the Internet, the traditional Chinese blood ties, geographic ties, karmic ties, and interest relationship have become digital strong ties, and that "interest relationship" are the most emerging and easier group to reach digital strong ties, and I used the interviews with members of gaming and fan circles to deduce and prove a model for the formation of digital strong ties. We reasoned and proved the formation model of digital strong ties, and found that digital strong ties has wider coverage and lower maintenance cost than traditional strong ties.

<img width="1050" alt="1" src="https://github.com/Jinaisrz/final_paper/assets/115119995/4e5ed5e8-ed6e-4972-bbfe-d1c7e16fc7a0">
<img width="1015" alt="2" src="https://github.com/Jinaisrz/final_paper/assets/115119995/93760580-4b5d-43ad-bf77-b0660e89c6fa">

# Week 2: 7.10-7.16
In that week, I analyzed Dr. Yanjie Bian's definition of traditional strong ties, the process of upgrading weak ties into digital strong ties, and the initial and stable phases of trust building in digital strong ties, and found that trust is like a kind of "social currency" that circulates multidimensionally in individual and group strong ties, because people have to build up enough trust in order to establish digital strong ties in any circumstances, and this kind of digital strong ties must have been born from long-time interactions with multidimensional interactions in the digital platform.

# Week 3: 7.17-7.23
Since trust is like a kind of "social currency", I try to analyze how trust circulates as a kind of currency in digital strong ties in a multi-dimensional way. Through reading the literature and analyzing the traditional strong ties and digital strong ties, I found that the core difference between them lies in the starting point of forming relationship - digital technology, because digital technology and platform are the foundation of the development of digital strong ties, and then rise to the establishment of person-to-person and person-to-group digital strong ties. Therefore, I define the direction of the circulation of trust as "trust-digital technologies and platforms-individuals-groups-results", but the details of the circulation need to be considered in this process.
<img width="727" alt="3" src="https://github.com/Jinaisrz/final_paper/assets/115119995/2ba4a90e-fc3a-4751-a792-80031d00708d">

# Week 4: 7.24-7.30
I think out the direction of the circulation of trust based on last week: trust-digital technologies and platforms-individuals-groups-results, and I try to build a model of the circulation of trust in strong digital ties. Taking trust as the center to disperse outward to the first level - digital technology and platform layer, I read the literature and look back to the previous interviews, and finally found that trust is firstly built up by the reputation of the platform to a certain extent, and the user's interest and interaction with some people in it will be recorded by the data, so as to recommend the corresponding community, and thus may be better able to reach the digital strong ties. In my exploration of other social platforms digital platforms also quantify trust in multiple ways, e.g., in QQ, the two interacting parties automatically set a friendship level by the number of days the chat lasts each day, and when the interaction is interrupted for more than 3 days it is downgraded, which uses the frequency of people's interactions as a way to quantify trust.
![4](https://github.com/Jinaisrz/final_paper/assets/115119995/03de8869-cb5c-44a8-b684-5fceac42df68)

In my personal level exploration, I find that people building digital identities in a more authentic, complete, coherent, and sincere way in a secure platform leads to more stable personal trust, deep self-disclosure, and strengthened trust and digitally strong ties with others. From this I find that trust has quantifiable characteristics.

# Week 5: 7.31-8.6
I encountered a lot of difficulties in that week's research, especially in the research on the group level, I have studied a lot of literature on virtual communities, digital identity of groups and other directions, and found that the topic could not be further deepened. So I found a typical "interest relationship" individual around me, and through interviewing her, I found that as fans of celebrities, they are given many digital socialization methods by the platform in their own digital strong ties, and they are also differentiated into obvious grades in the group through the interaction design of the platform, and the higher the grade, the higher the degree of trust they have and the corresponding benefits they will get. The higher the rank, the more trusted they are and the more benefits they receive, and this hierarchy of trust leads to a more orderly digital strong ties community. The rich interaction methods within the community developed by the digital platform will also increase the digital strong ties among the members, such as completing the system tasks together, which will increase the two-way trust and thus better shape the collective identity and culture.
Through Week 4 and Week 5, I found that trust circulates in digital strong ties in ways that can be quantified, facilitate deep socialization over time, the maintenance and shaping of group values, and extend digital strong ties.

# Week 6: 8.7-8.13
The difficult point of the week's research is to dig deeper into the critical direction of the topic, digging over the direction of the entanglement in the digital strong ties of trust fraud, digital strong ties of the causes of instability of social trust, the virtual true and false, whether the trust is fragmented, the digital strong ties of the group polarization, etc., the week has been constantly going to look for breakthroughs, the readings of more than 50 papers.

# Week 7: 8.14-8.20
That week I refreshed all the existing papers to make all the textual content more concise so as to try to find a point of strength for the paper, and eventually realized that all the directions I took last week would make the context incoherent. I looked at all the analytics and found that the trust built in the context of digitally strong ties with interesting people is collected and pushed by algorithmic preferences and built by multiple interaction design mechanisms, which is why I questioned, is the trust built in the context of digitally strong ties pure? Is it all about "free will"? So I started with a simple analysis of the algorithmic guidance of trust and the intervention of interaction design mechanisms, and found that algorithms and recommender systems are constantly guiding the direction of individual social groups based on individual interests and behaviors, and through reading papers, I found that the quantization of trust will turn what should be a rich and colorful trust into a single one-sided tendency of trust hierarchy.

# Week 8: 8.21-8.27
In that week, I analyzed last week's research and read the paper, and found that the platform as the soil for the development of strong digital ties exploits the trust of the digital strong ties of "interest relationship", and I firstly found some practical examples that can prove this speculation, and found that trust is also used for the development of digital platforms and user adhesion, which in fact strengthens the relationship between people and the digital platforms. strong digital ties with digital platforms. In other studies, it has been pointed out that platform capitalism and algorithms change the structure of trust, transforming trust ties into trust capital, which appears to be the result of autonomous decision-making brought about by people's "free will", but is essentially the result of the platform capital's purposeful steering using smart algorithms.

# Week 9: 8.28-9.3
During the week I searched for papers on the platform's trust capital, free will, and the economy of "interest relationship" to support the theory and enrich the overall content and structure of the paper, and to come up with an analysis of all of last week's content, ultimately reflecting on the blurring of the boundaries of people's freedom of trust and the loss of sovereignty over their trust, and reflecting on their perspectives.

# Week 10: 9.4-9.10
During that week, I streamlined any lengthy or unnecessary content in the paper and then summarized the research. Then, I combed through all the cited literature in the research and labeled it with its proper serial number and reordered the article titles of the existing paper.

# Week 11: 9.11-9.17
Based on my research in the previous weeks, I thought about the scenarios and I looked at a range of computer artists such as: Rafael Lozano-Hemmer's "The Listening Post" by Mark Hansen and Ben Rubin - a dynamic art installation that collects and broadcasts text from internet chat rooms in real time. Jenny Holzer's LED installations - Jenny Holzer uses scrolling LED text to convey information, thoughts and social commentary. "Processing" by Casey Reas and Ben Fry. Kyle McDonald's "Social Soul," an immersive, interactive installation that allows users to experience the social media lives of others, and Golan Levin, a new media artist and engineer who often explores the interactions between humans and machines. His works such as "Double-Taker (Snout)" use computer vision and robotics to mimic human social behaviour.

After looking at the artist references, I started thinking about project ideas.

People to "call" behaviour in front of the screen receiver speaker to send their preferences for interaction, the system will automatically match a community point, the more people interact with the community in front of the screen, the coarser the strength of the relationship, next to the interaction to achieve the trust index, and in the strength of the relationship with the algorithm inside! visual elements such as vision, delivery of interactive content, and empathy. But when people stop interacting, the system allows the strength to diminish and people are in a passive interaction process, which is used to satirise the impact of the system on people's "trust" building, until finally the screen plays a film on the evolution of the trust structure of the digital strong ties to make a viewpoint.
![5](https://github.com/Jinaisrz/final_paper/assets/115119995/a1adecba-22dc-47cb-a62d-9e47949b1d17)

# Week 12: 9.18-9.24
Unsatisfied with the first scenario, I rethought a new one and settled on one that was more related to human "trust" behaviour.

I create a social platform, the audience can experience the project from the user's perspective. This plan is inspired by people's the most typical trust behaviour-- the "handshake".

### Experience the process:

1. When the audience uses my social platform, they first need to enter their username, and their interest direction.

2. After the audience enters the platform, they will first see a simple social network of hand (the bone points of the hand is the friends' data points, and on the data point, there will be the friends'  interest direction, the trust level, the messages, emoji, and so on) The audience will strengthen the frequency of interaction by shaking hand with each time. The beginning of the handshake also gradually recommends you choose the interest group.

3. When the user's interaction frequency and interaction trust level reaches a hight level, the system will change, from the original people actively choose with whom to shake hands, into the system to help you choose with whom to shake hands (for example: the player in front of the different trust level users, one of them is a high-level user with a title, the player with whom to shake hands, the system will automatically reject, and display 'your trust level is not enough, you have been given'), thus making irony.

### Experience the process:
Hand movements are captured through leap motion LM010 capture, and I'll use processing to write the visuals and interactions.
<img width="359" alt="6" src="https://github.com/Jinaisrz/final_paper/assets/115119995/08dac55f-8be9-4b9e-803a-dbe73ea54ad3">

### Visual reference, Hand social network structure and Hand Angle:
<img width="1121" alt="7" src="https://github.com/Jinaisrz/final_paper/assets/115119995/aae995ce-a3db-4d5c-a3e7-a1fc8dd1901d">

### Main Visual Design
<img width="1293" alt="8" src="https://github.com/Jinaisrz/final_paper/assets/115119995/3e4d8443-b8f4-4c15-a564-ecd39d34a297">

# Week 13: 9.25-10.1
## Tutor feedback
<img width="936" alt="feedback1" src="https://github.com/Jinaisrz/final_paper/assets/115119995/51e04797-217e-4910-b2b4-bad6bd39f471">

Much of Marysia's feedback came from the social research portion of the dissertation, which required sorting out the dissertation format, haver citing references. And go ahead and develop a technical prototype if possible.

## Cancell leapmotion & Processing plan
### Problems:
1. Thresholding and edge detection process the hand image to make the pixel sense too strong.
2. Fingers will not be recognised due to the dimming of the light, making the test results even worse.
3. Hand recognition generates a large number of pixels that make the image loading too slow.
<img width="1018" alt="9" src="https://github.com/Jinaisrz/final_paper/assets/115119995/efde23f6-e1e4-4ae2-a76d-f9c7c9f3aabc">
<img width="873" alt="10" src="https://github.com/Jinaisrz/final_paper/assets/115119995/0a7e222e-ecc5-4b05-9d62-f1ccb1f52935">

4. Difficult to see hand outline
<img width="1027" alt="11" src="https://github.com/Jinaisrz/final_paper/assets/115119995/12e31ac5-7f53-4135-988c-cad2656fb222">

# Week 14: 10.2-10.8
## Tutor feedback
<img width="928" alt="feedback2" src="https://github.com/Jinaisrz/final_paper/assets/115119995/39dd6cb6-7308-4b74-9957-cfc120b3f66d">

The main tip from the mentor feedback is to avoid really storing personal information such as the player's face, email address, etc. as much as possible, which may involve some unnecessary privacy risks, and feel free to store usernames, passwords, and other data.

## I use P5.js and the computer's camera to recognise my hand
The hand has 20 bone points, and every two of them can connect a joint of the hand, which means that every 4 vectors connect one finger.
<img width="982" alt="14" src="https://github.com/Jinaisrz/final_paper/assets/115119995/401f5aee-8d33-4aca-87f6-387457af909a">
<img width="1037" alt="14 1" src="https://github.com/Jinaisrz/final_paper/assets/115119995/dde48631-1b58-439b-927e-ba88e106c590">

### The reference of hand model:
https://editor.p5js.org/ima_ml/sketches/lrBwwxGiF

I found a reference where the particles and interconnecting lines can represent user points and social networks.
![13](https://github.com/Jinaisrz/final_paper/assets/115119995/31b2260d-20b9-4133-8e37-67b754923934)

### Reference:
[https://editor.p5js.org/ima_ml/sketches/lrBwwxGiF](https://openprocessing.org/sketch/1901346)https://openprocessing.org/sketch/1901346

## How are particles generated and how are particles connected to each other into visual social networks?
### Theory of Particle Neighbour Technology
In the ParticleSystem class, there is a discoverNeighbours method that discovers neighbouring particles by calculating the distance between them. This method checks the distance between each particle and other particles and classifies them as "neighbours" if they are neither too close (more than MIN_TRI_DISTANCE) nor too far (less than MAX_TRI_DISTANCE). As in Figure, the maximum value of 10 between particles, it will be centered in the radius of the particle as the centre of the induction of adjacent particles, through the a.neighbourhood.push(b,c) will be b and c particles placed in the array of neighbours of the particle a, in which push can be added to the end of the array with one or more elements, and ultimately, b, c as the neighbours of the a, they can satisfy the conditions for the formation of triangles, while d , e, and f are too far away to satisfy the condition.
<img width="1101" alt="15" src="https://github.com/Jinaisrz/final_paper/assets/115119995/4c2ec60a-beaa-4e4f-a658-b675a4d8aeb7">

### Technical process of forming triangles using addTriangles algorithm
(1) Confirmation of Neighbourhood:
Particles a, b, c satisfy the condition that they are neighbours of each other as determined by discoverNeighbours method and traverse the array of particles, compare the distance between particles and add the particles that are within a certain distance to the a.neighbours array.

(2) Pass the neighbours array:
When the number of particles in a's neighbours array meets the conditions for creating triangles, this array is passed to the addTriangles method of the TriangleSystem class.

(3) Creating Triangle Instances:
The addTriangles method creates an instance of the Triangle class based on the neighbours array, which uses the positions of the three particles as the vertices of the triangle.

(4) Storing Triangles:
Each Triangle instance created is added to the internal array this.triangles of the TriangleSystem class.

(5) Drawing triangles:
Finally, in the display method, the TriangleSystem class iterates over all the created Triangle instances and draws them using the beginShape and endShape functions.

<img width="381" alt="16" src="https://github.com/Jinaisrz/final_paper/assets/115119995/8a83845d-3185-4223-b76a-1337011b4658">

## How do particles and triangles follow the movement?
Points a and b are two bone points that are connected to be the vector of joints. Then a random red point is generated on the vector based on GetPoints. Then make a normal line at the red point position of a vector, offsetPointByWidth generates the blue bias point, and offsetDistance sets the offset range to ±10. Use discoverNeighbours in ParticleSystem to get the bias points' position, then use addTriangles to generate the neighbourhood data, then use display to render the triangles out.
<img width="1049" alt="17" src="https://github.com/Jinaisrz/final_paper/assets/115119995/3f5571a1-0e5f-4f67-ab6f-214e9ccd51f1">

# Week 14: 10.9-10.15
## Mean Squared Error (MSE) for determining the "handshake" behaviour
In this week, In our system, the logic for detecting a handshake and increasing the number of particles and triangles heavily relies on calculating the Mean Squared Error (MSE) of key points on the hand. Mean Squared Error is a measure used to quantify the difference between sets of values. In this context, it's used to determine how close the key points of a hand are to each other in order to recognize if a handshake has occurred. When the hand is open, the 20 key points are more dispersed. Conversely, during a handshake gesture, these 20 points are collectively closer, resulting in an MSE value less than 6,000. Therefore, when the MSE drops below this threshold, it is determined that a handshake gesture has been completed.
<img width="926" alt="18" src="https://github.com/Jinaisrz/final_paper/assets/115119995/98fb6b4f-d334-4d5b-aa8a-8317dc58eabb">

# Week 15: 10.16-10.22
## Particles can't disappear, they need to keep growing
<img width="470" alt="22" src="https://github.com/Jinaisrz/final_paper/assets/115119995/75b74041-3c09-4ef0-8cba-b501352a089f">

The differentiation is initialising lifespan, updating lifespan and checking if the particle is "dead", in which every time the move method is called, the lifespan value will be decreasing because of the code this.lifespan -= LIFESPAN_DECREMENT; and this is contrary to the concept of a continuously growing number of users. constantly decreasing, so that the particles have the phenomenon of death, and this is contrary to the concept of continuous growth of the number of users, so you need to this.lifespan -= LIFESPAN_DECREMENT commented out, so that the lifespan value is never less than 0, you can let the number of particles to continue to grow, the particles will be due to addTriangles constantly increasing the number of triangles.

<img width="864" alt="19" src="https://github.com/Jinaisrz/final_paper/assets/115119995/b2c98f8b-b20e-4a83-ac2e-c5698f934cc4">

## Mean square error to determine the handshake and thus the colour change
### Mean square error handshake judgement
With my drawKeypoints function, the program uses the gesture recognition feature to detect hand poses. This procedure I started by traversing the predictions array, which contains the data for each hand recognised by the handpose model. For each hand's predictions, the program traverses all of its keypoints, draws those points, and calculates their mean square error with respect to the hand's centroid.

<img width="460" alt="24" src="https://github.com/Jinaisrz/final_paper/assets/115119995/796666a5-fbf3-4f32-9c0a-96b9a2f3d1fb">

This mean square error is obtained by calculating the sum of the squares of the distances from each keypoint to the centre point and dividing by the total number of keypoints. Based on the value of the mean square error, the program determines whether the hand is in a fisted state or not: if the mean square error is less than 6000 and the current isFist state is false, it is assumed that the hand is in a fisted state, and isFist is set to true, and the system.addParticle method is called to add particles in order to indicate that a fisted action is detected. Conversely, if the mean square error is greater than 6000, set isFist to false to indicate that the hand is not in a fist grip.

<img width="566" alt="25" src="https://github.com/Jinaisrz/final_paper/assets/115119995/d88271b8-ac09-479b-ba1a-e5086fef61c9">

### Resulting image of the mean square error handshake judgement
<img width="857" alt="23" src="https://github.com/Jinaisrz/final_paper/assets/115119995/b5737ada-0895-4c83-8acf-d6a7ff5362ae">

### Grip frequency affects colour change (for trust level design of colours)
1. the colour shade change of triangle is actually the colour shade change formed by whether multiple triangles overlap or not, for example, the particle generation is generated with the hand's as the vector, no matter how the hand moves, the particle's position with the vector will always be relatively unchanged, so the triangles generated by the same three points will be deeper in colour while the colour of the one alone will be lighter.

 <img width="316" alt="21" src="https://github.com/Jinaisrz/final_paper/assets/115119995/214e9ea9-fd0c-4b8d-acd5-89468d930b72">
   
2. I use meanSquaredError to determine if the hand is in a fisted state, and update the particles when the hand is in a fisted state. set isFist to true when meanSquaredError is below 6000 and isFist is false. subsequently, add particles in this state according to the value of state1, and increase the fistCount counter. The behaviour of the particles is controlled with the fistCount, and the fistCount keeps track of how many times the user performs the fist gesture, and the value of the fistCount is increased whenever a fist gesture is detected. This allows the program to understand how often and how much the user is interacting with the system. When the fistCount reaches a threshold value (25, 30, 40), the system.crazy method is called to add some particle dynamics.

<img width="534" alt="26" src="https://github.com/Jinaisrz/final_paper/assets/115119995/a41a1156-f2d1-4db6-a745-acbdca9d6a21">

3. The initial value of the colour is then set through the ColourGenerator's processColor. Finally the particles are coloured by displaying them in the Particle class, using the colour values generated by the ColourGenerator. First of all I have initialised MIN_SPEED, MAX_SPEED, R, G, B to control the speed of colour change and the initial colour values.
   
4. Then by defining three colour speeds (Rspeed, Gspeed, Bspeed) which are randomly determined to control the rate of change for each colour channel. In the final update method, you update the values for each colour channel. The colour values are increased or decreased according to their corresponding speed. Each colour value varies in a range from 0 to 255. If the colour value reaches the boundary of this range, the direction of the speed is reversed (this is achieved by means of the ternary operator) so that the colour value varies within the specified range. This class provides a mechanism to allow colours to change dynamically over time. Calling the update method from within an animation loop (such as the draw function) can be used to achieve a smooth transition of colours.

<img width="547" alt="27" src="https://github.com/Jinaisrz/final_paper/assets/115119995/8518351e-7351-411c-9cee-b3c5b8388591">
<img width="885" alt="28" src="https://github.com/Jinaisrz/final_paper/assets/115119995/2c097b0f-e419-4059-8399-2130eb3bb1b0">

# Week 16: 10.23-10.29
## Resulting image of the mean square error handshake judgement

### Defining option points (checkpoints)：
There are three checkpoints defined in the checkChosen() function, which are located at specific locations on the canvas.

<img width="473" alt="32" src="https://github.com/Jinaisrz/final_paper/assets/115119995/f049ba8b-e86d-4440-9910-dd8be5029643">

### Detects the position of the hand:
The palm position is calculated in the drawKeypoints() function, the exact line number may vary depending on the rest of the code, which focuses on calculating the centre point of the bounding box.

<img width="238" alt="33" src="https://github.com/Jinaisrz/final_paper/assets/115119995/f134b82a-7bd2-4e03-9290-7b869ab1425a">

### Determines how close the palm position is to the option point:
This part is also in the checkChosen() function, which determines proximity by comparing the distance between the palm position and a predefined checkpoint:

<img width="465" alt="34" src="https://github.com/Jinaisrz/final_paper/assets/115119995/2077f695-cb7e-41e3-a973-cdb666e3c644">

### Select processing:
The code updates the state1 variable when it detects that the palm is close to one of the checkpoints and is in the fist state. This is also in the checkChosen() function.

<img width="221" alt="35" src="https://github.com/Jinaisrz/final_paper/assets/115119995/72328afe-b4e5-4362-a92b-1c6c360b32c3">

### Results:
The error in selecting interest groups by hand recognition is very large because the control of the coordinates is problematic and can lead to trying to accurately select one while the other is also selected.

<img width="1042" alt="29" src="https://github.com/Jinaisrz/final_paper/assets/115119995/f7bdafe1-5fa2-4216-b861-4fc774c35d54">

## Change to Mouse Selection
<img width="555" alt="30" src="https://github.com/Jinaisrz/final_paper/assets/115119995/8a15070a-ab2c-4810-a1c2-dc1240c9e1d7">


## emoji选择
<img width="1283" alt="emoji-1" src="https://github.com/Jinaisrz/final_paper/assets/115119995/860cbb53-c9a6-499e-b602-8e2dd2db4d89">

<img width="1284" alt="emoji-2" src="https://github.com/Jinaisrz/final_paper/assets/115119995/2c5b273a-ddf3-4eb7-a14e-bacadb36f3ca">

![女明星](https://github.com/Jinaisrz/final_paper/assets/115119995/6cec624b-3606-4534-88ca-85e31a6d535d)

![埃隆马斯克](https://github.com/Jinaisrz/final_paper/assets/115119995/f53d7c77-c0e9-4a25-8827-dd05276952b1)




